searchState.loadedDescShard("haar_lib", 0, "Rust GitHub last commit\n代数的構造\nアルゴリズム\n引数から<code>std::collections::BTreeMap</code>を作る。\n引数から<code>std::collections::BTreeSet</code>を作る。\n値を最大値で更新する。\n値を最小値で更新する。\nデータ構造\nフロー問題\nC言語風のfor文\n幾何\n整数値での幾何\n<code>crate::io::fastio::FastIO</code>…\nブロック内のコードの実行時間を返す。\nグラフ一般に関するもの\nグリッド\n引数から<code>std::collections::HashMap</code>を作る。\n引数から<code>std::collections::HashSet</code>を作る。\n<code>Set</code>, <code>BinaryOp</code>, <code>Identity</code>, <code>Inverse</code>, <code>Commutative</code>, <code>Associative</code>,\n<code>From</code>を実装する。\n<code>crate::num::one_zero::One</code>, <code>crate::num::one_zero::Zero</code>…\n<code>Add</code>, <code>Sub</code>, <code>Mul</code>, <code>Div</code>, <code>Rem</code>, <code>AddAssign</code>, <code>SubAssign</code>, <code>MulAssign</code>, …\n<code>TryFrom</code>を実装する。\n<code>crate::io::fastio::FastIO</code>…\nIO\nイテレータ\n線形代数\nmacro_exportされたmacro置き場\nマッチング問題\n数学\n複数の値の最大値を得る。\n複数の値の最小値を得る。\n分類を放置しているもの /  …\n頂点倍加グラフ\n多次元の<code>Vec</code>を作る。\n数の構造体やトレイトなど\n<code>crate::io::fastio::FastIO</code>…\n構文解析\n乱数\n…\n複数の配列をソートする。\n…\nトレイトの別名を作る。\n木に関するもの\n遅延セグメント木などに載せる構造\nRange Add Range Min-Count用の代数的構造\nRange Add Range Sum用の代数的構造\n一次関数の合成を演算とする代数的構造\nRange Affine Range Sum用の代数的構造\n論理積を演算とする代数的構造\n論理和を演算とする代数的構造\n排他的論理和を演算とする代数的構造\n二面体群 $D_n$\n演算の順序を逆にした代数的構造\nFirst, Lastモノイド\n最大値を演算とする代数的構造\n<code>bool</code>値列の結合による、連続する<code>true</code>…\n…\n最小値を演算とする代数的構造\n最小値とその個数の総和\nOptionモノイド\n配列の置換を演算とする代数的構造\n乗算を演算とする代数的構造\n半環\n加法を演算とする代数的構造\n代数的構造に関するトレイトを定義する。\n配列の並び替えを演算とする代数的構造\n自明な群\n直積\nRange Update Range ~~~ 用の代数的構造\nRange Update Range Sum用の代数的構造\n遅延セグメント木などに載せる構造\n範囲更新の型\n範囲取得の型\n範囲更新を範囲取得に反映させる。\n…\n範囲取得のモノイドの単位元を返す。\n…\n範囲更新のモノイドの単位元を返す。\nRange Add Range Min-Count用の代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRange Add Range Sum用の代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n一次関数の合成を演算とする代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRange Affine Range Sum用の代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n論理積を演算とする代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n論理和を演算とする代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n排他的論理和を演算とする代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n二面体群$D_n$\n二面体群$D_n$の元\n回転\n鏡映\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n$D_n$の回転を表す元$R_i$を返す。\n$D_n$の鏡映を表す元$S_i$を返す。\n演算の順序を逆にした代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n最初に出現する<code>Some</code>を返す演算。\n最後に出現する<code>Some</code>を返す演算。\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n最大値を演算とする代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n連続する<code>true</code>列の最大長を管理する。\n最大連続長\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n左側最大連続長\n区間長\n<code>value</code>を値にもつ<code>MaxContiguous</code>を生成する。\n右側最大連続長\n…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n…\n値<code>value</code>をもつ長さ<code>1</code>の列に対応する<code>MaxPartialSum</code>…\n連続する空でない部分列の総和の最大値\n…\n列の総和\n最小値を演算とする代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n最小値とその個数の総和\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n置換操作\n$b_i = a_{P_i}$を満たすbを返す。\n操作を合成する。\nReturns the argument unchanged.\n<code>i</code>番目の要素を返す。\nCalls <code>U::from(self)</code>.\n逆操作を返す。\n単位元であるとき、<code>true</code>を返す。\n乗算を演算とする代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n半環\n可換で結合的な二項演算\nAddとMulの半環\n結合的な二項演算\n乗法の単位元\nXorとAndの半環\n加法の単位元\nAddとMulの半環\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nXorとAndの半環\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n加法を演算とする代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n可換群\n可換モノイド\n結合性をもつ\n二項演算をもつ\n可換性をもつ\n<code>fold_m</code>を提供する。\n群\n冪等性をもつ\n単位元をもつ\n逆元をもつ\nモノイド\n半群\n集合\n値に二項演算を複数回適用する。\nモノイドで畳み込んだ結果を返す。\n単位元\n逆元\n二項演算\n二項演算$\\circ$で(左側から)代入操作($a …\n二項演算$\\circ$で(右側から)代入操作($a …\n$\\underbrace{a \\circ a \\circ \\dots \\circ a \\circ a}_…\n変換操作\n$b_i = a_{T_i}$を満たすbを返す。\n操作を合成する。\nReturns the argument unchanged.\n<code>i</code>番目の要素を返す。\nCalls <code>U::from(self)</code>.\n単位元であるとき、<code>true</code>を返す。\n自明な群\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n2つの集合の直積\n3つの集合の直積\n4つの集合の直積\n5つの集合の直積\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRange Update Range ~~~ 用の代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRange Update Range Sum用の代数的構造\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n単調増加な判定関数上の二分探索\n二分探索\nCartesian tree\n座標圧縮\n循環検出法\n編集距離\nビット列の列挙\nグループ分けの方法の全列挙\n黄金分割探索\n1次元のimos法\n2次元のimos法\n等比級数のimos法\n区間スケジューリング問題\n転倒数\nKnuth-Morris-Pratt法\nナップサック問題\n最長共通部分列\n最長増加部分列\nBoyer-Moore majority vote algorithm\nManacher’s algorithm\n最大連続部分和\n最大長方形\nソート済み配列のマージ\nMo’s algorithm\nMonotone minima\n相異なる部分列の総数\n並列二分探索\n括弧列が対応が取れているかを調べる\n順列の列挙\nProject Selection Problem\nRun Length Encoding\nRolling Hash\nSuffix Array\n尺取り法\nスライド最小値\n配列に対する範囲頻度取得クエリ\n範囲転倒数取得クエリ\n最頻値取得クエリ\n部分和問題\n三分探索\n2-SAT\nZ algorithm\n全体で条件を満たさない。\n全体で条件を満たす。\n<code>ng</code>以下で条件を満たさず、<code>ok</code>…\n<code>ok</code>以下で条件を満たし、<code>ng</code>…\n<code>bsearch_ng_ok</code>、<code>bsearch_ok_ng</code>の返り値\n二分探索\n二分探索\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n条件を満たさない最大値\n条件を満たさない最小値\n条件を満たす最小値\n条件を満たす最大値\n<code>BinarySearch::lower_bound</code>,<code>BinarySearch::upper_bound</code>…\nlower_bound, upper_boundの組を求める。\nx以上となる最小のindexを求める。\nxを超える最小のindexを求める。\nCartesianTree\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n右の子の頂点\ndistinctな配列<code>a</code>から<code>CartesianTree</code>を構築する。\n親の頂点\n左の子の頂点\nCartesian treeの根\n座標圧縮のための構造体\n<code>Compressor&lt;T&gt;</code>を生成する\n座標圧縮対象に<code>value</code>を追加する。\n<strong>Time complexity</strong> $O(n \\log n)$\n<code>values</code>の要素をすべて座標圧縮する。\n<code>values</code>の要素をすべて復元する。\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>i</code>番目の値を返す。\n<code>value</code>が何番目の値(0-index)かを返す。\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n最大値を返す。\n最小値を返す。\n<code>CompressorBuilder&lt;T&gt;</code>を生成する。\n座標圧縮後の要素の種類数\n<code>cycle_finding</code>の結果\n循環部の長さ\n循環検出法\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n先頭の非循環部の長さ\n編集距離\nGray code\nビット列の部分集合を昇順に列挙する\n$a \\subseteq x \\subseteq b$を満たす<code>x</code>を列挙する\nビット列の部分集合を降順に列挙する\nビットが<code>1</code>の個数が<code>k</code>であるものを列挙する\nビット列の上位集合を昇順に列挙する\nビット列の上位集合を降順に列挙する\n<code>n</code>桁のGray codeを昇順に列挙する。\nビット列としての<code>a</code>…\n$a \\subseteq x \\subseteq b$を満たす<code>x</code>…\nビット列としての<code>a</code>…\n幅<code>width</code>のなかで、ビットが<code>1</code>の個数が<code>k</code>…\nビット列としての<code>a</code>…\nビット列としての<code>a</code>…\n<code>n</code>…\n<code>golden_search</code>…\n下に凸\n上に凸\nReturns the argument unchanged.\n黄金分割探索\nCalls <code>U::from(self)</code>.\n1次元のimos法\n<strong>Time complexity</strong> $O(n)$\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(n)$\n<strong>Time complexity</strong> $O(1)$\n2次元のimos法\n<strong>Time complexity</strong> $O(nm)$\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(nm)$\n<strong>Time complexity</strong> $O(1)$\n等比級数のimos法\n<strong>Time complexity</strong> $O(n)$\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(n)$\n<strong>Time complexity</strong> $O(1)$\n…\n数列の転倒数を計算する。\nKnuth-Morris-Pratt法\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity O(|s|)</strong>\n<strong>Time complexity O(|pat|)</strong>\n個数制限付きナップサック問題\n要素数が小さいナップサック問題\n価値の総和が小さいナップサック問題\n容量が小さいナップサック問題\n個数制限無しナップサック問題\n個数制限付きナップサック問題\n要素数が小さいナップサック問題\n価値の総和が小さいナップサック問題\n容量が小さいナップサック問題\n個数制限無しナップサック問題\n列a, bの最長共通部分列の一つを求める。\n列の最長増加部分列の一つを求める。\nBoyer-Moore majority vote algorithm\n<code>s</code>…\n…\n…\n…\n<code>a[0..k]</code>と<code>a[k..]</code>を<code>&lt;</code>で比較してマージする。\n<code>a[0..k]</code>と<code>a[k..]</code>を<code>cmp</code>で比較してマージする。\n2つのソート済み<code>Vec</code>をマージした<code>Vec</code>を返す。\nMo’s algorithm\n範囲<code>[l, r)</code>を登録する。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nクエリ処理用の関数を登録して<code>Mo</code>を作る。\n…\n<code>n</code>行<code>m</code>…\n返り値<code>ret</code>に対して、<code>ret[i]</code>は<code>a[0..i]</code>…\n並列二分探索\n括弧列が対応が取れているかを調べる\n<code>a</code>を辞書式順序で次の順列にする。\n辞書式順序で<code>a</code>…\n<code>a</code>を辞書式順序で前の順列にする。\nProject Selection Problem\nReturns the argument unchanged.\n頂点iが青ならばcの利益を得る。\n頂点iとjがともに青ならばcの利益を得る。\n頂点iとjがともに赤ならばcの利益を得る。\n頂点iが赤ならばcの利益を得る。\n頂点iが赤ならば、頂点jも赤…\nCalls <code>U::from(self)</code>.\n頂点iは青でなければならない。\n頂点iは赤でなければならない。\n<code>PSP</code>を生成する。\n頂点iが青ならばcの損失になる。\n頂点iとjが異なる色ならばcの損失となる。\n頂点iが赤ならばcの損失になる。\n頂点iが赤かつ頂点jが青…\nmust be制約を破った場合、<code>None</code>…\n<strong>Time complexity</strong> $O(|a|)$\n文字列のハッシュ値を計算する構造体。\n<code>RollingHash::hash_table</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\n文字列<code>s</code>のハッシュを計算する。\n範囲<code>l..r</code>でのハッシュを計算する。\n文字列<code>s</code>からハッシュ計算テーブルを作る。\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n最大長<code>size</code>、基数<code>b</code>と剰余の除数<code>m</code>を設定した…\n接尾辞配列\n接尾辞配列への参照を返す。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n接尾辞配列<code>s</code>について、<code>s[i]</code>と<code>s[i-1]</code>…\n文字列<code>s</code>から接尾辞配列を構築する。\n尺取り法\n…\n…\n…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(|a|)$\n<strong>Time complexity</strong> $O(\\log |a|)$\n範囲転倒数取得クエリ\n範囲<code>l..r</code>…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(n \\log n)$\nクエリに対しての結果を返す。\n最頻値取得クエリ\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n配列<code>a</code>での最頻値クエリを構築する。\n範囲<code>range</code>での最頻値とその出現回数を返す。\n部分和問題 …\n…\n部分和問題 …\n…\n<code>ternary_search</code>…\n下に凸\n上に凸\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n三分探索\n2-SATを解く。\n$a \\Rightarrow b$\n$a \\lor b$\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(size)$\n$\\lnot (a \\land b)$\n<strong>Time complexity</strong> $O(size + E)$\nZ algorithm\nAho-Corasick法\n非負整数を2進数として管理する。\n任意サイズのbit列を扱う。\nConvex Hull Trick\n1次元累積和\n2次元累積和\n半群の列の区間取得($O(1)$)ができる。\nモノイド列の区間更新・点取得($O(\\log n)$, …\n動的双対セグメント木\n動的遅延セグメント木\n動的セグメント木\n可換群の点更新・区間取得($O(\\log n)$, $O(\\log …\n可換な加減算に特化したFenwickTree\nFenwick木上にFenwick木を構築する。\n半群で畳み込み可能なdeque\nMexを求められるデータ構造\n最大値と最小値を得られるヒープ\nモノイド列の区間更新・区間取得($O(\\log n)$, …\n係数乗算付き区間加算区間総和遅延セグ木\n遅延加算付き融合可能ヒープ\nLi-Chao tree\nLink-Cut Tree\n連結リスト\nMerge-sort Tree\n同一要素を複数個挿入可能な<code>Set</code>\n順序付き辞書\n順序付き集合\n回文木\n部分永続UnionFind\n永続配列\n永続キュー\n永続セグメントツリー\n永続スタック\n永続UnionFind\nポテンシャル付きUnionfind\n64分木\n領域内の点を列挙する\nロールバック可能Unionfind\nロールバック可能Vec\nモノイド列の点更新・区間取得($O(\\log n)$, …\n二次元のセグメント木\nSegment Tree Beats\n区間一次関数加算セグメントツリー\n…\n…\n融合可能ヒープ\n…\n…\nSplay Tree\n区間加算・区間Max(Min)\n区間加算・個数総和付き区間Max(Min)\n完結ビットベクトル\nTrie木\n素集合データ構造\n<code>usize</code>を用いた集合表現\nWavelet matrix\nAho-Corasick法\n<code>AhoCorasick</code>を構築するための構造体。\n<code>AhoCorasick</code>のノード\nパターン<code>pat</code>を追加する。\n<code>AhoCorasick</code>を構築する。\n文字<code>c</code>で遷移する子ノードへの参照を返す。\n…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nノード毎に割り当てられた番号を返す。\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nノード数を返す。\n文字列<code>s</code>…\n<code>AhoCorasickBuilder</code>を生成する。\n<code>index</code>…\n…\nTrie木の根ノードへの参照を返す。\n非負整数を2進数として管理する。\n値<code>value</code>の個数を返す。\n値<code>value</code>…\nReturns the argument unchanged.\n値<code>value</code>を挿入して、<code>value</code>の個数を返す。\nCalls <code>U::from(self)</code>.\n要素数が0ならば<code>true</code>を返す。\n要素数を返す。\n$\\max_{a \\in S} a \\oplus xor$を求める。\n$\\min_{a \\in S} a \\oplus xor$を求める。\n<code>bitlen</code>ビットの数を扱える<code>BinaryTrie</code>…\n<code>Bitset</code>内部で扱う型のBit数\n任意サイズのbit列を扱う。\n<code>1</code>が設定されているbitの個数を数える。\n<code>0</code>が設定されているbitの個数を数える。\n<code>n</code>番目のbitを反転させる。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nbit列が空ならば<code>true</code>を返す。\nbit列の長さを返す。\n長さ<code>n</code>の<code>Bitset</code>を構築する。\n末尾の値を削除して返す。\n末尾に値<code>val</code>を追加する。\n<code>n</code>番目のbitを<code>val</code>で設定する。\n<code>n</code>番目のbitが<code>1</code>ならば<code>true</code>を返す。\nConvex hull trick\n<code>ConvexHullTrick&lt;T&gt;</code>がt扱える型\n最大値クエリ\n最小値クエリ\n最大値クエリか最小値クエリかを表す\n…\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n…\n…\n1次元の累積和を扱う\n<code>CumulativeSum1D</code>を構築する\n<code>i</code>番目に<code>value</code>を代入する\n<code>CumulativeSum1D</code>を構築する\n<strong>Time complexity</strong> $O(1)$\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>CumulativeSum1DBuilder</code>を生成する\n群<code>G</code>の演算に<code>i</code>番目の値と<code>value</code>を適用して<code>i</code>…\n2次元の累積和を扱う\n<code>CumulativeSum2D</code>を構築する\n<code>[i][j]</code>番目に<code>value</code>を代入する\n<code>CumulativeSum2D</code>を構築する\n<strong>Time Complexity</strong> $O(1)$\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>CumulativeSum2DBuilder</code>を生成する\n群<code>G</code>の演算に<code>[i][j]</code>番目の値と<code>value</code>を適用して…\n半群の列の区間取得($O(1)$)ができる。\n<strong>Time complexity</strong> $O(1)$\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n列<code>seq</code>から<code>DisjointSparseTable&lt;S&gt;</code>を構築する。\nモノイド列の区間更新・点取得($O(\\log n)$, …\nReturns the argument unchanged.\nスライスで初期化する。\n<strong>Time complexity</strong> $O(\\log n)$\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(n)$\n遅延操作を完了させたモノイド列を<code>Vec</code>…\n<strong>Time complexity</strong> $O(\\log n)$\n動的双対セグメント木\nReturns the argument unchanged.\n<code>i</code>番目の要素を取得する。\nCalls <code>U::from(self)</code>.\n<code>DynamicDualSegtree&lt;M&gt;</code>を生成する。\n範囲<code>s..t</code>を<code>value</code>で更新する。\n動的遅延セグメント木\n範囲<code>s..t</code>で計算を集約する。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>DynamicLazySegtree&lt;A&gt;</code>を生成する。\n範囲<code>s..t</code>を<code>value</code>で更新する。\n動的セグメント木\n<code>i</code>番目の要素を<code>value</code>で更新する。\n範囲<code>start..end</code>で計算を集約する。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>DynamicSegtree&lt;M&gt;</code>を生成する。\n可換群の点更新・区間取得($O(\\log n)$, $O(\\log …\n範囲<code>l..r</code>で計算を集約した結果を返す。\n範囲<code>0..r</code>で計算を集約した結果を返す。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n長さ<code>size</code>、可換群<code>group</code>から<code>FenwickTree&lt;G&gt;</code>…\n<code>i</code>番目の要素を<code>value</code>で更新する。\n<code>FenwickTreeAdd&lt;T&gt;</code>が扱える型\n可換な加減算に特化したFenwickTree\n<code>i</code>番目の値に<code>value</code>を足す。\n範囲<code>l..r</code>の総和を返す。\n範囲<code>0..r</code>の総和を返す。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n…\n長さ<code>size</code>の<code>FenwickTreeAdd&lt;T&gt;</code>を生成する。\n<code>i</code>番目の値から<code>value</code>を引く。\nFenwick木上にFenwick木を構築する。\n<code>FenwickOnFenwick</code>を構築するための構造体。\n点<code>(x, y)</code>を登録する。\n<code>FenwickOnFenwick</code>を構築する。\n<strong>Time Complexity</strong> $O(\\log ^ 2 n)$\n<strong>Time Complexity</strong> $O(\\log ^ 2 n)$\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n空の<code>FenwickOnFenwickBuilder</code>を用意する。\n<strong>Time Complexity</strong> $O(\\log ^ 2 n)$\n半群で畳み込み可能なdeque\n末尾の要素への参照を返す。\nすべての要素を<code>S</code>…\nReturns the argument unchanged.\n先頭の要素への参照を返す。\nCalls <code>U::from(self)</code>.\n要素数が<code>0</code>なら<code>true</code>を返す。\n要素数を返す。\n空の<code>FoldableDeque&lt;S&gt;</code>を生成する。\n末尾の要素を削除して返す。\n先頭の要素を削除して返す。\n末尾に<code>value</code>を追加する。\n先頭に<code>value</code>を追加する。\n…\n<code>x</code>を含むかを判定\nReturns the argument unchanged.\n<code>x</code>を追加する\n<code>x</code>を含む半開区間を返す\nCalls <code>U::from(self)</code>.\n<code>self</code>に含まれない数のうち<code>x</code>以上で最小のもの\n空の<code>IntegerSet</code>を生成\n<code>x</code>を削除する\n最大値と最小値を得られるヒープ\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n要素数が<code>0</code>ならば<code>true</code>を返す。\n要素数を返す。\n最大値の参照を返す。\n最小値の参照を返す。\n空の<code>IntervalHeap&lt;T&gt;</code>を構築する。\n最大値を削除して返す。\n最小値を削除して返す。\n値<code>item</code>を挿入する。\nモノイド列の区間更新・区間取得($O(\\log n)$, …\n<code>i</code>番目の値を<code>value</code>で置き換える。\n区間<code>range</code>で計算を集約して返す。\nReturns the argument unchanged.\n<code>i</code>番目の値を返す。\nCalls <code>U::from(self)</code>.\n長さ<code>n</code>の<code>LazySegtree</code>を生成する。\n<code>Vec</code>から<code>LazySegtree</code>を構築する。\n区間<code>range</code>を値<code>x</code>で更新する。\n<code>LazySegtreeCoeff&lt;T&gt;</code>が扱える型\n係数乗算付き区間加算区間総和遅延セグ木\n範囲<code>range</code>で総和を取る。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n‍係数<code>coefficients</code>を設定した<code>LazySegtreeCoeff</code>…\n<code>self.fold(i..i+1) = value[i]</code>…\n範囲<code>range</code>に値<code>value</code>を加算する。\n<code>LazySkewHeap&lt;T&gt;</code>が扱える型\n遅延加算付き融合可能ヒープ\nヒープの全要素に値<code>value</code>を加算する。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nヒープが空ならば<code>true</code>を返す。\nヒープに含まれている値の個数を返す。\n他の<code>LazySkewHeap&lt;T&gt;</code>を融合する。\n空の<code>LazySkewHeap</code>を生成する。\nヒープの最大値を返す。\n…\n値<code>value</code>を挿入する。\n<code>LiChaoTree&lt;T&gt;</code>が扱える型\n…\n最大値クエリ\n最小値クエリ\n最大値クエリか最小値クエリかを表す\n直線を追加する。\n線分を追加する。\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>query</code>で使用する点列<code>xs</code>…\n<code>x</code>での最大値/最小値を返す。\nLink-Cut Tree\n頂点<code>i</code>と頂点<code>j</code>の間にある辺を削除する。\n頂点<code>i</code>,<code>j</code>…\nReturns the argument unchanged.\n頂点<code>k</code>の値を返す。\nCalls <code>U::from(self)</code>.\n頂点<code>i</code>と頂点<code>j</code>の間に辺を張る。\n<code>LinkCutTree&lt;M&gt;</code>を生成する。\n頂点<code>k</code>の値を<code>x</code>に変更する。\n頂点<code>k</code>の値をモノイドの演算と値<code>x</code>…\n複数の連結リストをまとめたもの\n連結リストの内部ノード\n<code>prev</code>の後ろに<code>next</code>を接続する。\n<code>cur</code>が属する連結リストの先頭を返す。\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>cur</code>から<code>cur</code>…\n<code>cur</code>が属する連結リストの末尾を返す。\n<code>LinkedListPool</code>を生成する。\n<code>cur</code>の次の要素\n<code>cur</code>の前の要素\n<code>value</code>…\n<code>cur</code>から<code>cur</code>…\n<code>cur</code>の後ろでリストを切断する。\n<code>cur</code>の前でリストを切断する。\n<code>Node</code>がもつ値\nMerge-sort Tree\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(n \\log n)$\n<code>ub</code>以下の総和を求める\n同一要素を複数個挿入可能な<code>Set</code>\n値<code>value</code>が含まれていれば、<code>true</code>を返す。\n値<code>value</code>が含まれている個数を返す。\n先頭の要素を返す。\nReturns the argument unchanged.\n値<code>value</code>を挿入する。\nCalls <code>U::from(self)</code>.\n要素数が0ならば、<code>true</code>を返す。\n末尾の要素を返す。\n要素数を返す。\n<code>MultiSet&lt;T&gt;</code>を生成する。\n先頭の要素を<em>一つだけ</em>削除して返す。\n末尾の要素を<em>一つだけ</em>削除して返す。\n値<code>value</code>を<em>一つだけ</em>削除する。\n順序付き辞書\n<code>key</code>…\n<code>key</code>をキーとして持つならば<code>true</code>を返す。\n順序付き辞書のすべての要素を順番に<code>f</code>…\nReturns the argument unchanged.\nキー<code>key</code>に対応する値の参照を返す。\n<code>i</code>…\n<code>i</code>番目のキーへの参照を返す。\nキー<code>key</code>に対応する値の可変参照を返す\n<code>i</code>番目のキーに対応する値への参照を返す。\n<code>i</code>…\n<code>key</code>がすでに存在している場合、値を<code>value</code>…\nCalls <code>U::from(self)</code>.\n要素数が<code>0</code>ならば<code>true</code>を返す。\n要素数を返す。\n<code>key</code>…\n<code>key</code>…\n空の<code>OrderedMap</code>を返す。\nキー<code>key</code>…\n<code>i</code>…\n順序付き集合\n<code>key</code>…\n<code>key</code>をキーとして持つならば<code>true</code>を返す。\n順序付き辞書のすべての要素を順番に<code>f</code>…\nReturns the argument unchanged.\n<code>i</code>番目のキーへの参照を返す。\n<code>key</code>が存在するとき、<code>key</code>を挿入して、<code>true</code>…\nCalls <code>U::from(self)</code>.\n要素数が<code>0</code>ならば<code>true</code>を返す。\n要素数を返す。\n<code>key</code>以下の最大のキーをもつキーを返す。\n<code>key</code>以上の最小のキーをもつキーを返す。\n空の<code>OrderedSet</code>を返す。\nキー<code>key</code>があれば、そのキーを削除して、<code>true</code>…\n<code>i</code>番目の要素を削除して、そのキーを返す。\n<code>PalindromicTree</code>のノード\n回文木\n…\nノードが表す回文の出現回数を返す。\n偶数長回文の木の根への参照を返す。\nReturns the argument unchanged.\nReturns the argument unchanged.\nノードに割り当てられた番号を返す。\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n…\n回文の長さを返す。\n文字列<code>s</code>から回文木を構築する。\n元の文字列の長さ<code>pos+1</code>…\n<code>index</code>番目のノードへの参照を返す。\n奇数長回文の木の根への参照を返す。\n親ノードへの参照を返す。\n末尾に文字<code>c</code>を追加する。\n…\n…\nある時間での<code>PartiallyPersistentUnionFind</code>…\n部分永続UnionFind\n時刻tでの状態\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>u</code>と<code>v</code>が同じ素集合に含まれていれば<code>true</code>…\n最新時点の状態\n<code>u</code>を含む素集合と<code>v</code>を含む素集合を融合する。\n大きさ<code>size</code>の<code>PartiallyPersistentUnionFind</code>…\n<code>i</code>を含む素集合の代表の値を返す。\n<code>u</code>が属する素集合の大きさを返す。\n永続配列\nReturns the argument unchanged.\n<strong>Time complexity</strong> $O(\\log n)$\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(n)$\n<strong>Time complexity</strong> $O(\\log n)$\n永続キュー\n末尾の要素への参照を返す。\nReturns the argument unchanged.\n先頭の要素への参照を返す。\nCalls <code>U::from(self)</code>.\nキューが空ならば<code>true</code>を返す。\nキューの要素数を返す。\n値<code>value</code>をただ一つだけもつ<code>PersistentQueue</code>…\n先頭の要素を削除した<code>PersistentQueue</code>を返す。\n値<code>value</code>を末尾に追加した<code>PersistentQueue</code>を返す。\n永続セグメントツリー\n<code>i</code>番目の要素を<code>value</code>にする。\n範囲<code>range</code>で計算を集約して返す。\nReturns the argument unchanged.\n<code>Vec</code>から<code>PersistentSegtree</code>を構築する。\nCalls <code>U::from(self)</code>.\n長さ<code>n</code>の<code>PersistentSegtree</code>を生成する。\n永続スタック\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n…\n空の<code>PersistentStack</code>を生成する。\n末尾の要素への参照を返す。\n末尾の要素を削除した<code>PersistentStack</code>を返す。\n値<code>value</code>を末尾に追加した<code>PersistentStack</code>を返す。\n永続UnionFind\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>i</code>と<code>j</code>が同じ集合にぞくするならば、<code>true</code>…\n<code>i</code>の属する集合と<code>j</code>の属する集合を統合する。\n大きさ<code>n</code>の<code>PersistentUnionFind</code>を返す。\n<code>i</code>の属する集合の根を返す。\n<code>i</code>の属する集合の大きさを返す。\nポテンシャル付きUnionfind\n素集合の個数を返す。\n<code>i</code>と<code>j</code>…\nReturns the argument unchanged.\n素集合をすべて列挙する。\nCalls <code>U::from(self)</code>.\n<code>i</code>と<code>j</code>が同じ素集合に属するならば<code>true</code>…\n<code>i</code>の属する素集合と<code>j</code>…\n大きさ<code>n</code>の<code>PotentialUnionFind</code>…\n大きさ<code>n</code>の<code>PotentialUnionFind</code>…\n<code>i</code>のポテンシャル($P(i)$)を返す。\n<code>i</code>の属する素集合の根を返す。\n<code>i</code>の属する素集合の大きさを返す。\n<code>QwordTree</code>で扱える最大値\n0 ~ 16777215 (2²⁴ - 1) の値の集合を管理する\nxを含むかどうかを判定する\nxを集合から削除する\nSafety\nReturns the argument unchanged.\nxを集合に加える\nSafety\nCalls <code>U::from(self)</code>.\n集合が空かどうかを判断する\n集合に含まれている要素数を返す\n最大値を返す\nx以下で最大の値を返す\n最小値を返す\nx以上で最小の値を返す\n64分木を生成\nRange search tree\n<code>RangeSearchTree</code>を構築するための構造体。\n点<code>(x, y)</code>を登録する。\n<code>RangeSearchTree</code>を構築する。\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n空の<code>RangeSearchTreeBuilder</code>を用意する。\n$[sx, tx), [sy, …\nロールバック可能Unionfind\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>i</code>と<code>j</code>が同じ素集合に属するかを判定する\n<code>i</code>の属する素集合と<code>j</code>…\n<code>RollbackableUnionFind</code>を生成する\n直前の<code>merge</code>操作を巻き戻す\n<code>i</code>の属する素集合の根を返す\n<code>i</code>の属する素集合の大きさを返す\nロールバック可能Vec\nスライスを返す\n<code>index</code>番目の要素を<code>value</code>に変更する\n先頭の要素を返す\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n要素が存在しないかを判定する\n末尾の要素を返す\n現在の要素数を返す\n<code>RollbackableVec</code>を生成\n末尾の要素を削除して返す\n末尾に<code>value</code>を追加\n直前の<code>push</code> / <code>pop</code> / <code>assign</code>操作を取り消す\nモノイド列の点更新・区間取得($O(\\log n)$, …\n<strong>Time complexity</strong> $O(\\log n)$\n<strong>Time complexity</strong> $O(\\log n)$\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(n)$\n<strong>Time complexity</strong> $O(\\log n)$\n二次元のセグメント木\n<strong>Time complexity</strong> $O(\\log w \\log h)$\n<strong>Time complexity</strong> $O(\\log w \\log h)$\nReturns the argument unchanged.\n<strong>Time complexity</strong> $O(1)$\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(wh)$\n<strong>Time complexity</strong> $O(\\log w \\log h)$\nSegment Tree Beats\n区間<code>range</code>に値<code>x</code>を加算する。\n区間<code>range</code>を値<code>x</code>…\n区間<code>range</code>を値<code>x</code>…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n区間<code>range</code>の最大値を返す。\n区間<code>range</code>の最小値を返す。\n長さ<code>n</code>の<code>SegtreeBeats</code>を生成する。\n区間<code>range</code>の総和を返す。\n<code>SegtreeLinearAdd&lt;T&gt;</code>が扱える型\n区間一次関数加算セグメントツリー\nReturns the argument unchanged.\n<strong>Time complexity</strong> $O(\\log n)$\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(n)$\n範囲<code>l..r</code>に一次関数<code>ax + b</code>の値を加算する。(<code>x</code>…\n<code>SegtreeLinearAddRangeSum&lt;T&gt;</code>が扱える型\n…\n<strong>Time complexity</strong> $O(\\log n)$\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(n)$\n<strong>Time complexity</strong> $O(\\log n)$\n…\n<code>SegtreeOnSegtree</code>を構築するための構造体。\n点<code>(x, y)</code>を登録する。\n<code>SegtreeOnSegtree</code>を構築する。\n<code>[x1, x2), [y1, y2)</code>で計算を集約する。\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n空の<code>SegtreeOnSegtreeBuilder</code>を用意する。\n点<code>(x, y)</code>の値を<code>value</code>で更新する。\n融合可能ヒープ\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nヒープが空ならば<code>true</code>を返す。\nヒープに含まれている値の個数を返す。\n他の<code>SkewHeap&lt;T&gt;</code>を融合する。\n空の<code>SkewHeap&lt;T&gt;</code>を生成する。\nヒープの最大値を返す。\n…\n値<code>value</code>を挿入する。\n…\n<strong>Time complexity</strong> $O(1)$\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(n \\log n)$\n…\n<strong>Time complexity</strong> $O(1)$\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(nm \\log n \\log m)$\nスプレーツリー\n<code>start..end</code>…\n列の要素を始めから辿り、その参照を<code>f</code>…\nReturns the argument unchanged.\n<code>index</code>番目の要素の参照を返す\n要素を<code>index</code>番目になるように挿入する\nCalls <code>U::from(self)</code>.\nスプレーツリーが要素を持たなければ<code>true</code>…\nスプレーツリーの要素数を返す\n左側にスプレーツリーを結合する\n右側にスプレーツリーを結合する\nモノイド<code>m</code>をもつ<code>SplayTree&lt;M&gt;</code>を生成\n先頭の値を削除する\n末尾の値を削除する\n先頭に値を追加する\n末尾に値を追加する\n<code>index</code>番目の要素を削除して、値を返す\n<code>start..end</code>の範囲を反転させる\n<code>index</code>番目の要素を<code>value</code>に変更する\n値<code>value</code>をもつノード一つのみからなる…\n左側に<code>index</code>…\n区間Max\n区間Min\n区間Max/Minを選択する。\n区間加算・区間Max(Min)ができるデータ構造。\n<strong>Time complexity</strong> $O(\\log n)$\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(n)$\n<strong>Time complexity</strong> $O(\\log n)$\n区間Max\n区間Min\n区間Max/Minを選択する。\n…\n<strong>Time complexity</strong> $O(\\log n)$\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(n)$\n<strong>Time complexity</strong> $O(\\log n)$\n完結ビットベクトル\n<code>index</code>番目のビットを返す。\n[l, r) に含まれる<code>b</code>の個数\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nビットベクトルの長さが<code>0</code>なら<code>true</code>を返す。\nビットベクトルの長さを返す。\n<code>Vec&lt;bool&gt;</code>から<code>SuccinctBitVec</code>を構築する。\n[0, index) に含まれる<code>b</code>の個数\nnth(0-indexed)番目の<code>b</code>の位置\nTrie木\nTrie木のノード\n列<code>s</code>をTrie木に追加する。\n…\n…\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n値<code>value</code>を保持するルートのみをもつ<code>Trie</code>…\nTrie木の根ノードへの参照を返す。\nTrie木の根ノードへの可変参照を返す。\nノードに格納している値\n…\n素集合の個数を返す。\nReturns the argument unchanged.\n素集合をすべて列挙する。\nCalls <code>U::from(self)</code>.\n<code>i</code>と<code>j</code>が同じ集合に属するならば<code>true</code>を返す。\n<code>i</code>の属する集合と<code>j</code>の属する集合を統合する。\n大きさ<code>1</code>の集合を<code>n</code>個用意する。\n<code>i</code>の属する集合の根を返す。\n<code>i</code>の属する集合の大きさを返す。\n<code>i</code>の属する集合のもつ値を返す。\n大きさ<code>1</code>の集合を<code>|values|</code>…\n<code>usize</code>のビット数個の要素をもつ集合を表す。\n<code>i</code>が集合に含まれているかを判定する。\n<code>self</code>から<code>rhs</code>を引いた差集合を返す。\n<code>0</code>から<code>n</code>までを要素に含む集合を得る。\n<code>i</code>が集合に含まれていなければ、<code>i</code>…\nReturns the argument unchanged.\n2つの集合の共通部分を返す。\nCalls <code>U::from(self)</code>.\n集合が空かを判定する。\n集合の大きさを返す。\n<code>i</code>を削除した集合を返す。\n<code>i</code>を追加した集合を返す。\n2つの集合の対象差を返す。\n2つの集合の和集合を返す。\n<code>u32</code>の列を管理できる<code>WaveletMatrix</code>\n<code>u64</code>の列を管理できる<code>WaveletMatrix</code>\nWavelet matrix\n<code>index</code>番目の値を得る。\n<code>range</code>に含まれる<code>value</code>の個数。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>range</code>での最大値\n<code>range</code>での最小値\n<code>T</code>の列から<code>WaveletMatrix</code>を作る。\n<code>range</code>で<code>lb</code>以上の最小値\n<code>range</code>で<code>ub</code>未満の最大値\n<code>range</code>で<code>nth</code>(0-indexed)番目に小さい値。\n<code>range</code>で<code>lb</code>以上<code>ub</code>未満の値の個数\n[0, index)に含まれる<code>value</code>の個数。\n<code>nth</code>(0-indexed)番目の<code>value</code>の位置。\n容量の型\n最大フロー問題を扱うトレイト。\n頂点<code>u</code>から頂点<code>v</code>へ容量<code>cap</code>の辺を張る。\n最大流 (Dinic)\n最大流 (Ford-Fulkerson)\n…\n頂点<code>s</code>から頂点<code>t</code>への最大フローを求める。\n最小費用流\n頂点数<code>n</code>の空のグラフを返す。\nフローを初期化する。\nDinic法\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFord-Fulkerson法\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n最小費用流\n頂点<code>u</code>から頂点<code>v</code>に容量<code>cap</code>・費用<code>cost</code>…\nReturns the argument unchanged.\n頂点<code>i</code>に接続する辺を、<code>(終点, 流量, 費用)</code>…\nCalls <code>U::from(self)</code>.\n始点<code>src</code>から終点<code>sink</code>へ流量<code>f</code>…\n頂点数<code>size</code>の空の<code>MinCostFlow</code>を返す。\n円\n<code>f64</code>の誤差を許容する演算を提供する。\n直線 (線分)\n二次元ベクトル\n絶対値を計算する\n線分の大きさを返す。\n絶対値の2乗を計算する\nベクトルのなす角度を返す\n<code>self</code>から<code>other</code>への角度($-\\pi \\le \\theta \\le …\n円と多角形の共通部分の面積\n2つの円の共通部分の面積\n多角形の面積\n点と線分の位置関係\n円の中心\n三角形の外接円\n最近点対\n2つの円の共通接線\n凸多角形の判定\n凸多角形の直線での切断\n凸多角形の直径\n凸包\n外積を計算する\n2つの線分の外積を求める。\n始点から終点に向かうベクトルを返す。\n直線と点の距離\n線分と点の距離\n2つの線分間の距離\n内積を計算する\n2つの線分の内積を求める。\n誤差を許容して<code>a == b</code>なら<code>true</code>を返す。\n2つのベクトルが等しければ<code>true</code>を返す。\n2つの線分が等しければ<code>true</code>を返す。\n円が等しいかを判定する\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n線分の始点\n誤差を許容して<code>a &gt;= b</code>なら<code>true</code>を返す。\n誤差を許容して<code>a &gt; b</code>なら<code>true</code>を返す。\n三角形の内接円\n円と直線の位置関係\n円と線分の位置関係\n2つの円の位置関係\n直線と線分の位置関係\n2つの線分の位置関係\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n2つの直線が直交していれば<code>true</code>を返す。\n2つの直線が平行していれば<code>true</code>を返す。\n誤差を許容して<code>a &lt;= b</code>なら<code>true</code>を返す。\n誤差を許容して<code>a &lt; b</code>なら<code>true</code>を返す。\n誤差を許容して<code>a != b</code>なら<code>true</code>を返す。\n誤差<code>eps</code>を設定して<code>Eps</code>を生成する。\n始点と終点を設定した<code>Line</code>を返す。\n中心<code>center</code>、半径<code>radius</code>の<code>Circle</code>を生成する\n直交するベクトルを返す\n線分と直交するベクトルを返す。\n<code>a</code>と<code>b</code>の比較をする。\n点と多角形の位置関係\n極座標形式で<code>Vector</code>を生成する\n点<code>p</code>…\n円の半径\n直線を対象軸とした点<code>p</code>…\n点を通る円の接線\n線分の終点\n長さを<code>1</code>にしたベクトルを返す\n線分方向の単位ベクトルを返す。\n円と多角形の共通部分の面積を求める。\n2つの円の共通部分の面積を求める\n多角形の面積を求める\n点と線分の位置関係\n…\n…\n…\n…\n点が線分上にある。\n<code>p0</code>から<code>p1</code>に向かう線分に対して、点<code>p2</code>…\n<code>CLOCKWISE</code>ならば<code>true</code>を返す。\n<code>COUNTER_CLOCKWISE</code>ならば<code>true</code>を返す。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>ON_SEGMENT</code>ならば<code>true</code>を返す。\n<code>ONLINE_BACK</code>ならば<code>true</code>を返す。\n<code>ONLINE_FRONT</code>ならば<code>true</code>を返す。\n<code>ONLINE_BACK</code>または<code>COUNTER_CLOCKWISE</code>ならば<code>-1</code>…\n三角形(△abc)の外接円を求める\n最近点対を求める。\n2つの円の共通接線を求める\n多角形<code>ps</code>が凸多角形であれば<code>true</code>を返す。\n凸多角形<code>ps</code>を直線<code>l</code>…\n凸多角形の直径を求める\n凸包の上半分か下半分かを指定する\n下半分\n上半分\n凸包を求める\nReturns the argument unchanged.\n上半分/下半分の凸包を求める\nCalls <code>U::from(self)</code>.\n直線と点の距離を求める\n線分と点の距離を求める\n2つの線分間の距離を求める\n三角形(△abc)の内接円を求める\n直線と円が交わっている\n円と直線の位置関係\n直線が円の外側にある\n直線が円に接している\n<code>CROSSED</code>かを判定\nReturns the argument unchanged.\n円と直線の位置関係と交点を求める\nCalls <code>U::from(self)</code>.\n<code>OUTSIDE</code>かを判定\n<code>TANGENT</code>かを判定\n線分が円の内部にある\n円と線分の位置関係\n線分が円と一つの交点をもつ\n線分が円の外部にある\n線分が円に接している\n線分が円と二つの交点をもつ\nReturns the argument unchanged.\n<code>INSIDE</code>かを判定\n円と線分の位置関係と交点を求める\nCalls <code>U::from(self)</code>.\n<code>ONE_CROSSPOINT</code>かを判定\n<code>OUTSIDE</code>かを判定\n<code>TANGENT</code>かを判定\n<code>TWO_CROSSPOINT</code>かを判定\n…\n…\n一方の円がもう一方の円の内部にある\n2つの円が交差している\n2つの円の位置関係\n一方の円がもう一方の円の外部にある\n2つの円が同じである\n<code>CIRCUMSCRIBED</code>かを判定\nReturns the argument unchanged.\n<code>INSCRIBED</code>かを判定\n<code>INSIDE</code>かを判定\n2つの円の位置関係と交点を求める\n<code>INTERSECTED</code>かを判定\nCalls <code>U::from(self)</code>.\n2つの円の共通接線の個数を返す。但し、<code>SAME</code>…\n<code>OUTSIDE</code>かを判定\n<code>SAME</code>かを判定\n線分が直線と交差している\n直線と線分の位置関係\n線分が直線の左側にある\n線分が直線上にある\n線分が直線の右側にある\n<code>CROSSED</code>かを判定\nReturns the argument unchanged.\n直線と線分の位置関係と交点を求める\nCalls <code>U::from(self)</code>.\n<code>LEFTSIDE</code>かを判定\n<code>OVERLAPPED</code>かを判定\n<code>RIGHTSIDE</code>かを判定\n2つの線分が交差している\n2つの線分の位置関係\n2つの線分が交差していない\n2つの線分が重なっている\n2つの線分が同一である\nReturns the argument unchanged.\n2つの線分の位置関係と交点を求める\n<code>INTERSECTED</code>かを判定\nCalls <code>U::from(self)</code>.\n<code>NOT_INTERSECTED</code>かを判定\n<code>OVERLAPPED</code>かを判定\n<code>SAME</code>かを判定\n点が多角形の外部にある\n点が多角形の内部にある\n点が多角形上にある\n点と多角形の位置関係\n<code>EXCLUSION</code>かを判定\nReturns the argument unchanged.\n<code>INCLUSION</code>かを判定\nCalls <code>U::from(self)</code>.\n<code>ON_SEGMENT</code>かを判定\n点と多角形の位置関係を求める\n点<code>p</code>を通る円<code>c</code>の接線を求める\n整数値をもつ二次元ベクトル\n絶対値を計算する\n絶対値の2乗を計算する\nベクトルのなす角度を返す\n<code>self</code>から<code>other</code>への角度($-\\pi \\le \\theta \\le …\n偏角ソート\n最近点対\n凸包\n外積を計算する\n内積を計算する\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n二次元ベクトル(x, y)を返す。\n直交するベクトルを返す\nx座標\ny座標\n偏角ソートした<code>Vec</code>を返す。\n最近点対を求める。\n凸包の上半分か下半分かを指定する\n下半分\n上半分\n凸包を求める\nReturns the argument unchanged.\n上半分/下半分の凸包を求める\nCalls <code>U::from(self)</code>.\n有向辺をもつ。\n…\nグラフの辺\n<code>Graph</code>にもたせる辺の満たすトレイト。\nグラフ\nグラフのノード\n無向辺をもつ。\n辺の重みの型\n無向グラフに辺を追加する。\n有向グラフに辺を追加する。\n関節点の列挙\n負閉路を持つグラフの最短経路 (Bellman-Ford)\n幅優先探索\n二重頂点連結分解\n二部グラフ判定\n橋の列挙\n中国人郵便配達問題\n有向グラフ上の最小有向全域木を求める\n閉路検出\n有向グラフの閉路検出\n非負重み付き最短経路 (Dijkstra)\n接続する辺\n…\n(準)Eulerグラフの判定\n辺の始点\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n辺の始点\nFunctional Graph\n辺の番号など\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nグラフの頂点数が<code>0</code>ならば<code>true</code>を返す。\n最小全域木 (Kruskal)\nグラフの頂点数を返す。\nLowlink\n最大独立集合\n<code>from</code>から<code>to</code>への重さ<code>weight</code>、辺番号<code>index</code>…\n頂点数が<code>size</code>の空の<code>Graph</code>を構築する。\n<code>i</code>番目の頂点の<code>GraphNode</code>への参照を返す。\n各頂点の<code>GraphNode</code>…\n最小全域木 (Prim)\n…\n逆辺\n強連結成分分解\n辺の終点\n辺の終点\nトポロジカルソート\n巡回セールスマン問題\n二重辺連結成分分解\n全頂点間最短経路長\n辺の重み\n辺の重み\n最短パスを<code>k</code>個列挙する。\n関節点の列挙\n負閉路を持つグラフの最短経路\n幅優先探索で辺数が最小の経路を得る。\n二重頂点連結分解\n…\n橋の列挙\n<strong>Time complexity</strong> $O(V^2 2^V)$\n有向グラフ上の最小有向全域木を求める\n…\n…\n有向グラフの閉路検出\nダイクストラ法\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n最短距離の配列への参照を返す。\n<code>to</code>への最短距離を返す。 …\n<code>to</code>への最短パスを返す。 …\nグラフ<code>g</code>…\n…\n有向グラフの(準)Eulerグラフの判定\n無向グラフの(準)Eulerグラフ判定\n有向グラフでの一筆書き\n有向辺<code>e</code>を追加する。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n頂点数<code>size</code>のグラフを用意する。\n…\n無向グラフでの一筆書き\n無向辺<code>e</code>を追加する。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n頂点数<code>size</code>のグラフを用意する。\n…\n<code>Loop</code>でも<code>Leaf</code>でもない頂点。\n各頂点の出次数が<code>1</code>である、<code>n</code>頂点<code>n</code>…\n<code>FunctionalGraph</code>を構築するための構造体。\n連結成分\n頂点の種類\n入次数が<code>0</code>の頂点。\n閉路を構成している頂点。\n<code>from</code>から<code>to</code>への有向辺を追加する。\n枝\n<code>FunctionalGraph</code>を構築する。\n…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n頂点<code>i</code>…\n頂点<code>i</code>の属する連結成分を返す。\nすべての連結成分への参照を返す。\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>Branch</code>ならば<code>true</code>を返す。\n<code>Leaf</code>ならば<code>true</code>を返す。\n<code>Loop</code>ならば<code>true</code>を返す。\n頂点<code>i</code>の種類を返す。\n葉\n閉路\n<code>n</code>頂点の空なグラフを用意する。\n頂点<code>i</code>から辺を辿った次の頂点を返す。\nKruskal法\nLowlink\npar, chのどちらにも属さないノード\nDFS木での子ノード\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n…\n無向グラフから<code>Lowlink</code>を構築する。\nDFSで頂点を訪れた順番\nDFS木での親ノード\nグラフの頂点数\n最大独立集合を求める\nPrim法\n<code>PseudoTree</code>の頂点の種類\n閉路を構成する頂点。\n閉路以外の頂点。\n…\n<code>PseudoTree</code>を構築するための構造体。\n<code>u, v</code>間に無向辺を張る。\n<code>PseudoTree</code>を構築する。\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>Loop</code>ならば<code>true</code>を返す。\n頂点<code>i</code>の種類を返す。\n頂点数<code>n</code>の空のグラフを用意する。\n頂点<code>i</code>…\n強連結成分分解\nReturns the argument unchanged.\n強連結成分を返す。\n…\nCalls <code>U::from(self)</code>.\nグラフから<code>SCC</code>を構築する。\nトポロジカルソート\n巡回セールスマン問題\n二重辺連結成分分解\nグラフの全頂点間の最短距離を管理する。\n…\n<code>from</code>から<code>to</code>への最短距離を返す。\nReturns the argument unchanged.\n負の閉路があれば<code>true</code>を返す。\nCalls <code>U::from(self)</code>.\n<code>WarshallFloyd&lt;T&gt;</code>を生成する。\n…\n有向グラフ<code>g</code>上で<code>from</code>から<code>to</code>…\n下方向への1マス分の移動\n…\n移動方向\n長方形型のマス目グリッドを扱う。\n左方向への1マス分の移動\nグリッド上の位置を表す。\n右方向への1マス分の移動\n上方向への1マス分の移動\nx方向の移動量\ny方向の移動量\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n位置<code>p</code>の要素への参照を返す。\n位置<code>p</code>の要素への可変参照を返す。\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n…\n…\n<code>(self.x + d.dx, self.y + d.dy)</code>に相当する<code>Position</code>を…\n<code>(0, 0) ~ (h - 1, w - 1)</code>の長方形内の位置<code>(x, y)</code>…\n移動量<code>(dx, dy)</code>の<code>Dir</code>を返す。\n<code>Vec&lt;Vec&lt;T&gt;&gt;</code>などから<code>Grid</code>を構築する。\nグリッドをグラフに変換する\nx方向の位置\ny方向の位置\nグリッドをグラフに変換する\n高速な標準入出力\n高速な標準入出力\nReturns the argument unchanged.\n1バイトだけ読み出す。\nCalls <code>U::from(self)</code>.\n<code>FastIO</code>を生成する。\n1バイトだけ先読みする。\n文字列を<code>Vec&lt;u8&gt;</code>として読み出す。\n文字列を<code>Vec&lt;char&gt;</code>として読み出す。\n<code>f64</code>型の数値を読み出す。\n<code>i32</code>型の数値を読み出す。\n<code>i64</code>型の数値を読み出す。\n<code>isize</code>型の数値を読み出す。\n文字列を<code>String</code>として読み出す。\n<code>u32</code>型の数値を読み出す。\n<code>u64</code>型の数値を読み出す。\n<code>usize</code>型の数値を読み出す。\n<code>is_ascii_whitespace</code>が<code>true</code>である間を読み飛ばす。\n<code>s</code>を標準出力に書き込む。\n<code>s</code>を標準出力に<strong>逆順</strong>に書き込む。\n<code>s</code>と改行文字を標準出力に書き込む。\n<code>s</code>の<strong>逆順</strong>と改行文字を標準出力に書き込む。\n<code>bit_ones</code>と<code>bit_zeros</code>を提供する。\n<code>collect_vec</code>を提供する。\n<code>cumsum</code>を提供する。\n<code>join_str</code>を提供する。\n<code>reject</code>を提供する。\n<code>bit_ones</code>と<code>bit_zeros</code>を提供する。\nビットが<code>1</code>である桁を昇順に列挙する。\nビットが<code>0</code>である桁を昇順に列挙する。\n<code>collect_vec</code>を提供する。\n<code>.collect::&lt;Vec&lt;_&gt;&gt;()</code>と同じ。\n<code>cumsum</code>を提供する。\n累積和を返すイテレータを生成する。\n<code>join_str</code>を提供する。\n要素を<code>String</code>に変換して、要素間に<code>s</code>…\n<code>reject</code>を提供する。\n<code>predicate</code>…\n大きさがコンパイル時固定の行列\nmod 2\n任意mod\nmod 素数p\n半環上の行列\n$\\mathbb{F}_2^{64}$上の要素{$a_1, \\dots, …\n<code>R</code>×<code>C</code>の行列\nReturns the argument unchanged.\n<code>i</code>行<code>j</code>列の要素への参照を返す。\n<code>i</code>行<code>j</code>列の要素への可変参照を返す。\nCalls <code>U::from(self)</code>.\nゼロ行列を返す。\n転置行列を返す。\n単位行列を返す。\n行列式 (mod 2)\nガウスの消去法 (mod 2)\n逆行列 (mod 2)\n連立一次方程式$A \\boldsymbol{x} = \\boldsymbol{b} …\n行列 (mod 2)\nmod 2上で行列式を求める\nmod 2上で行列を掃き出し、ランクを求める。\nmod 2上で逆行列を求める\n連立一次方程式$A \\boldsymbol{x} = \\boldsymbol{b} …\n行列 (mod 2)\nReturns the argument unchanged.\n<code>Bitset</code>の<code>Vec</code>から<code>MatrixMod2</code>を生成する\n<code>i</code>行<code>j</code>列の成分を返す\nCalls <code>U::from(self)</code>.\n<code>h</code>行<code>w</code>列の<code>MatrixMod2</code>を生成\n行列の転置を得る\n<code>h</code>×<code>w</code>行列\n正方行列\n<code>h</code>×<code>w</code>行列\nReturns the argument unchanged.\n<code>Vec&lt;Vec&lt;u32&gt;&gt;</code>から<code>Matrix&lt;Modulo&gt;</code>を作る。\n<code>i</code>行<code>j</code>列の要素への可変参照を返す。\n行列の行数を返す。\nCalls <code>U::from(self)</code>.\n<code>h</code>×<code>w</code>の零行列を作る。\n<code>w</code>×<code>h</code>の転置行列を作る。\n行列の列数を返す。\n正方行列\nReturns the argument unchanged.\n<code>Vec&lt;Vec&lt;u32&gt;&gt;</code>から<code>SquareMatrix</code>を作る。\n<code>i</code>行<code>j</code>列の要素への可変参照を返す。\nCalls <code>U::from(self)</code>.\n<code>size</code>×<code>size</code>の零行列を作る。\n行列の<code>p</code>乗を求める。\n行列の行数(列数)を返す。\n愚直に行列積を求める。\nStrassenのアルゴリズムによる行列乗算\n行列の転置を求める。\n<code>size</code>×<code>size</code>の単位行列を作る。\n行列式 (mod 素数)\nガウスの消去法 (mod p)\n逆行列 (mod 素数)\n連立一次方程式$A \\boldsymbol{x} = \\boldsymbol{b} …\n素数mod p上での行列式を求める。\nmod p上で行列を掃き出し、ランクを求める。\n素数mod p上での逆行列を求める。\n連立一次方程式$A \\boldsymbol{x} = \\boldsymbol{b} …\n半環上の行列\nReturns the argument unchanged.\n<code>i</code>行<code>j</code>列の要素への参照を返す。\n<code>i</code>行<code>j</code>列の要素への可変参照を返す。\nCalls <code>U::from(self)</code>.\n行列<code>a</code>の<code>n</code>乗を求める。\n<code>w</code>×<code>h</code>の転置行列を作る。\n行列積$ab$を求める。\n<code>n</code>×<code>n</code>の単位行列を返す。\n<code>h</code>×<code>w</code>の零行列を返す。\n$\\mathbb{F}_2^{64}$上の要素{$a_1, \\dots, …\n<code>chmax!</code>, <code>chmin!</code>\n<code>impl_from!</code>, <code>impl_try_from!</code>\n<code>hashset!</code>, <code>btreeset!</code>, <code>hashmap!</code>, <code>btreemap!</code>\n<code>for_loop!</code>\n<code>get_time!</code>\n<code>impl_algebra!</code>\n<code>impl_one_zero</code>\n<code>impl_ops!</code>\n<code>get!</code>, <code>input!</code>\n<code>max!</code>, <code>min!</code>\n<code>mul_vec!</code>\n<code>rec!</code>\n<code>sort_with!</code>\n<code>timer!</code>\n<code>trait_alias!</code>\n二部マッチング\n二部マッチング (Hopcroft-Karp)\n最大フローによる最大二部マッチング\n左側<code>i</code>と右側<code>j</code>に辺を張る。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n最大マッチングの辺数を返す。\n左側の頂点数が<code>left</code>、右側の頂点数が<code>right</code>…\n…\n左側<code>i</code>と右側<code>j</code>に辺を張る。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n最大マッチングの辺集合を返す。\n左側の頂点数が<code>left</code>、右側の頂点数が<code>right</code>…\nベル数$B(n, n)$のテーブル\n線形漸化式を求める。\nベルヌーイ数$B_0, \\dots, B_n$を列挙する。\n二項係数\n閉区間\n連分数展開\n畳み込み\n互いに素な数を数える。\n中国剰余定理\n約数列挙\n拡張ユークリッドの互除法\n階乗\na!の素因数pの個数を求める。\n素因数分解\nFormal Power Series\nGarner’s algorithm\n最大公約数・最小公倍数\nKth root\n$y = ax + b$の直線\n一次合同方程式を解く。\nmod mでの演算\n完全順列の個数を列挙する。\n多項式の多点評価\nNimber product\n数論変換 (Number Theoretic Transform)\n$\\#_p$ Subset sum\n分割数$p(0), \\dots, p(n)$を列挙する。\n$\\mathbb{F}_p$上の多項式\n多項式$f(x)$に対して、$f(x + …\n素数判定\n原始根\nStern-Brocot木\n第二種スターリング数$S(n, 0), \\dots, S(n, …\n第二種スターリング数$S(0,0), \\dots, …\n$\\sum_{i=0}^{n-1} \\lfloor \\frac{ai+b}{m} \\rfloor$\n$\\sum_{i=0}^{\\infty} r^ii^d$\n$a \\uparrow \\uparrow b \\pmod m$\nトーシェント関数\nトーシェント関数の総和\nベル数$B(0, 0)$~$B(n, n)$を求める。\n$N$項の数列$a_0, a_1, \\ldots, a_{N-1}$から、 …\nベルヌーイ数$B_0, \\dots, B_n$を列挙する。\n二項係数$_nC_k \\pmod m$を計算する。\n二項係数$_nC_k …\n$_nC_k \\pmod{p^q}$を計算する。\n$_nC_k \\pmod m$を計算する。\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n素数$p$に対して$\\pmod{p^q}$で<code>ExtLucas</code>…\n$\\pmod m$で<code>BinomialCoefficient</code>を用意する。\n両端の点を含む閉区間を扱う。\n閉区間の終了地点\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n…\n<code>ClosedInterval&lt;T&gt;</code>を生成する\n閉区間の開始地点\n$\\frac{a}{b}$を連分数展開する。\n$\\mathtt{a_{i \\land j}} = \\sum \\mathtt{f_{i}} * \\mathtt{g_…\n$\\mathtt{a_{\\gcd (i, j)}} = \\sum \\mathtt{f_{i}} * \\mathtt{g…\n$\\mathtt{a_{i \\lor j}} = \\sum \\mathtt{f_{i}} * \\mathtt{g_…\n$\\mathtt{a_{i \\oplus j}} = \\sum \\mathtt{f_{i}} * \\mathtt{g_…\n高速Möbius変換\n$\\mathtt{a_k} = \\sum_{\\mathtt{i \\lor j = k, i \\land j = …\n高速Ζ変換\n$\\mathtt{a_{i \\land j}} = \\sum \\mathtt{f_{i}} * \\mathtt{g_…\n$\\mathtt{a_{\\gcd (i, j)}} = \\sum \\mathtt{f_{i}} * \\mathtt{g…\n$\\mathtt{a_{i \\lor j}} = \\sum \\mathtt{f_{i}} * \\mathtt{g_…\n$\\mathtt{a_{i \\oplus j}} = \\sum \\mathtt{f_{i}} * \\mathtt{g_…\n$\\mathtt{f_j} = \\sum_{\\mathtt{i \\subseteq j}} …\n$\\mathtt{f_j} = \\sum_{\\mathtt{i \\supseteq j}} …\n$\\mathtt{a_k} = \\sum_{\\mathtt{i \\lor j = k, i \\land j = …\n$\\mathtt{F_j} = \\sum_{\\mathtt{i \\subseteq j}} …\n$\\mathtt{F_j} = \\sum_{\\mathtt{i \\supseteq j}} …\n<code>n</code>以下の自然数で、<code>m</code>…\n二元の中国剰余定理\n多元の中国剰余定理\n約数の個数を数える\n約数を列挙する\n<code>enumerate_quotients</code>の結果\n1以上N以下の自然数xについて<code>floor(N/x)</code>…\nReturns the argument unchanged.\n<code>x</code>の最小値\nCalls <code>U::from(self)</code>.\n<code>floor(N/x)</code>の値\n<code>x</code>の最大値\n拡張ユークリッドの互除法\n有限体上での階乗の計算を行う構造体。\nベル数\nベルヌーイ数\nカタラン数\nn個からk個とりだす組み合わせの個数 (${}_n …\nnの階乗\nReturns the argument unchanged.\nn個から重複を許してk個選ぶ場合の数 (${}_n …\nCalls <code>U::from(self)</code>.\nnの階乗の逆元\n<strong>Time complexity</strong> $O(n)$\nn個からk個とりだす順列の個数 (${}_n \\mathrm{ …\n第二種スターリング数\nベル数\n計算結果の型\nベル数$B(n, k)$を計算する。\nベルヌーイ数\n計算結果の型\nベルヌーイ数$B_0 \\ldots B_n$を計算する。\nカタラン数\n計算結果の型\nカタラン数$C_n$を計算する。\n計算結果の型\n第二種スターリング数\n第二種スターリング数$S(n,k)$を計算する。\na!の素因数pの個数を求める。\n前計算による素因数分解\n試し割り素因数分解\n前計算による素因数分解\n<code>n</code>の素因数を列挙する。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>n</code>以下の非負整数を素因数分解できる…\n試し割り素因数分解\n形式的冪級数\n多項式の型\n$f(x) = \\sum_0^{n-1} a_ix^i$について、$\\exp …\n$f(x) = \\sum_0^{n-1} …\n$f(x) = \\sum_0^{n-1} a_ix^i$について、$\\log …\n$f(x) = \\sum_0^{n-1} …\n$$ \\begin{aligned} x \\equiv r_1 \\pmod {m_1} \\\\ x \\equiv …\n最大公約数・最小公倍数\nGCD,LCMの計算結果の型\n最大公約数を求める。\n最大公約数と最小公倍数を求める。\n最小公倍数を求める。\n$\\lfloor a^{1/k} \\rfloor$を求める。\n$y = ax + b$の直線を表す。\n‍直線の傾き\n<code>x</code>に値を代入した結果を返す。\n直線のy切片\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nx方向に<code>dx</code>だけ平行移動した直線を返す。\nax + b = 0 (mod m) を満たすxを求める。\n0,1,..,nの素数mod pでの逆元を列挙する。\nmod mでの逆元\n素数mod pでの逆元\naˣ = b (mod m)を満たすxを求める。\nxᵖ (mod m)を求める。\nx² = a (mod p)を満たすxを一つ求める。\n0,1,..,nの素数mod pでの逆元を列挙する。\nmod mでの逆元\n素数mod pでの逆元\naˣ = b (mod m)を満たすxを求める。\nxᵖ (mod m)を求める。\nx² = a (mod p)を満たすxを一つ求める。\n長さ<code>0</code>から<code>n</code>…\n多項式の多点評価\n多項式の型\n多項式の係数の型\n多項式の多点評価\n<code>u16</code>同士のNimber productを求める。\n<code>u32</code>同士のNimber productを求める。\n<code>u64</code>同士のNimber productを求める。\n<code>u8</code>同士のNimber productを求める。\n素数$P$上の数論変換 (Number Theoretic Transform)\n$\\mod 998244353 (= 2^{23} * 7 * 17 + 1)$上の<code>NTT</code>\n2つの<code>Vec</code>を畳み込む。\n<code>convolve(f.clone(), f)</code>と同等。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>ntt</code>の逆変換を行う。\nNTTで変換可能な配列の最大長を返す。\n<code>NTT&lt;P, PRIM_ROOT&gt;</code>を作る。\n数論変換を行う。\n$\\#_p$ Subset sum\n分割数$p(0), \\dots, p(n)$を列挙する。\n$\\mathbb{F}_p$上の多項式\n多項式の演算を扱う。\n多項式<code>a</code>と多項式<code>b</code>の和を返す。\n多項式<code>a</code>に多項式<code>b</code>を足す。\n$x^i$の係数を得る。\n定数項のみをもつ多項式を生成する。\n多項式の次数を返す。\n多項式の微分を返す。\n多項式<code>a</code>の多項式<code>b</code>による商と剰余を返す。\n多項式に値<code>p</code>を代入した結果を求める。\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>len()</code>を超えないように、先頭<code>t</code>…\n多項式の積分を返す。\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n項数が<code>0</code>のとき<code>true</code>を返す。\n内部の<code>Vec</code>の長さを返す。\n多項式<code>a</code>と多項式<code>b</code>の積を返す。\n多項式<code>a</code>に多項式<code>b</code>を掛ける。\n<code>NTT&lt;P&gt;</code>を基に<code>PolynomialOperator&lt;P&gt;</code>を生成する。\n多項式<code>a</code>の<code>k</code>倍を返す。\n係数を<code>k</code>…\n係数を<code>k</code>…\n係数が<code>0</code>の高次項を縮める。\n多項式<code>a</code>の2乗を返す。\n多項式<code>a</code>と多項式<code>b</code>の差を返す。\n多項式<code>a</code>から多項式<code>b</code>を引く。\n零多項式を得る。\n多項式の型\nPolynomial Taylor shift\n多項式の係数の型\n多項式 <code>p</code> = $f(x) = a_0 + a_1x + \\cdots + …\n素数判定\nEratosthenesの篩\n<code>value</code>が素数ならば<code>true</code>を返す。\nMiller-Rabin素数判定法\nEratosthenesの篩\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>size</code>までの自然数の素数判定ができる…\nMiller-Rabin素数判定法\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n原始根\n分数$\\frac{a}{b}$を表す。\n左の子を<code>n</code>回辿る操作を表す。\n右の子を<code>n</code>回辿る操作を表す。\n子ノードへの移動を表す。\nStern-Brocot木上の頂点を表す。\n…\nStern-Brocot木の根からノード<code>a</code>…\nノードの表す値を<code>f64</code>型に変換する。\nノードの表す値を<code>Frac</code>型に変換する。\n<code>SBPath</code>から<code>SBNode</code>への変換をする。\n<code>Frac</code>から<code>SBPath</code>への変換をする。\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>Frac</code>から<code>SBNode</code>に変換する。\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStern-Brocot木上でのノード<code>a</code>とノード<code>b</code>…\n左側の子を<code>n</code>回辿った先のノードを返す。\nノードの内部の4つ組の数を返す。\n…\n右側の子を<code>n</code>回辿った先のノードを返す。\nStern-Brocot木の根を返す。\n第二種スターリング数$S(n, 0), \\dots, S(n, …\n第二種スターリング数$S(0,0), \\dots, …\n$\\sum_{i=0}^{n-1} \\lfloor \\frac{ai+b}{m} \\rfloor$\n$\\sum_{i=0}^{\\infty} r^ii^d$\n$a \\uparrow \\uparrow b \\pmod m$を求める。\n<code>n</code>と互いに素である自然数の個数を求める。\n<code>n</code>…\nトーシェント関数の総和\n6面サイコロ\n最大値を<code>NULL</code>として扱う<code>usize</code>\n二次元<code>Vec</code>の要素swap\nタプルの<code>Vec</code>を<code>Vec</code>のタプルに変換する。\n…\n6面サイコロ\n後ろの面\n下の面\nReturns the argument unchanged.\n前の面\nCalls <code>U::from(self)</code>.\n左の面\n<code>Dice&lt;T&gt;</code>を生成する。\n右の面\n…\n…\n…\n…\n…\n…\n上の面\nNULLとして扱う値(<code>usize</code>の最大値)\n最大値を<code>NULL</code>として扱う<code>usize</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>NULL</code>ならば<code>true</code>を返す\n<code>RangeBounds&lt;usize&gt;</code>を実装した<code>r</code>を半開区間<code>start..end</code>…\n<code>a[i1][j1]</code>と<code>a[i2][j2]</code>を交換する。\n<code>Vec</code>のタプルを表す型\nタプルの<code>Vec</code>を<code>Vec</code>のタプルに変換する。\nタプルの<code>Vec</code>を<code>Vec</code>のタプルに変換する。\n<code>MulGraph</code>の辺\n頂点倍加グラフ\n<code>from</code>から<code>to</code>への有向辺を張る。\n<code>u</code>,<code>v</code>間に双方向に辺を張る。\n頂点倍加グラフ上でのDijkstra法\nReturns the argument unchanged.\nReturns the argument unchanged.\n始点\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n頂点<code>cur</code>…\n始点<code>from</code>、終点<code>to</code>、重さ<code>weight</code>…\n空のグラフを作る。\n終点\n重み\nDijkstra法\n四則演算ができる型\n複素数\nコンパイル時にmod Mが決まるModInt\n有限体\nガウス整数\n実行時にmod Mが決まるModInt\nMontgomery乗算\n正の無限大、負の無限大をもつ数\n加法と乗法の単位元を定める。\n演算を定義するトレイト\n有理数\n全順序を実装した<code>f64</code>\n数の性質のトレイト\n四則演算ができる型\n複素数\n絶対値$|z| = \\sqrt{a^2 + b^2}$を返す。\n偏角$\\arg z \\in (-\\pi, \\pi]$を返す。\n複素共役$\\bar{z} = a - bi$を返す。\nReturns the argument unchanged.\n虚部\nCalls <code>U::from(self)</code>.\n直交座標系の複素数$a + bi$を返す。\n極座標系の複素数$re^{ia}$を返す。\n実部\n<code>M</code>で剰余をとる構造体。\n<code>ConstModInt&lt;M&gt;</code>を生成するための構造体。\n<code>ConstModInt&lt;M&gt;</code>の代数的構造\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>ConstModInt&lt;M&gt;</code>を生成する。\n有限体の元の型\n有限体\n有限体の元\n<code>a/b</code>を生成する。\n<code>i64</code>から生成する。\n<code>u64</code>から生成する。\n<code>self</code>の乗法の逆元を返す。\n剰余の除数を返す。\n<code>self</code>の<code>p</code>乗を返す。\n内部の値を取り出す。\nガウス整数 $a + bi (a, b \\in \\mathbb{Z})$\n$\\mathtt{self} = q \\times \\mathtt{b} + r (N(b) &gt; …\n$\\mathtt{self} = q \\times \\mathtt{b} + r (N(b) &gt; …\nReturns the argument unchanged.\n<code>self</code>と<code>b</code>の最大公約数を返す。\n虚部\nCalls <code>U::from(self)</code>.\n<code>self</code>が$0 + 0i$ならば<code>true</code>を返す。\nガウス整数$a + bi$を返す。\n<code>self</code>のノルム$N(\\mathtt{self})$を返す。\n実部\n$\\mathtt{self} = q \\times \\mathtt{b} + r (N(b) &gt; …\n<code>modulo</code>を法として剰余をとる構造体。\n<code>ModInt</code>を生成するための構造体。\n<code>ModInt</code>の代数的構造\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>modulo</code>を法とする<code>ModIntBuilder</code>を生成する。\n<code>value</code>を値にもち、<code>modulo</code>を法とする<code>ModInt</code>…\n<code>mod m</code>上の乗法\n<code>mod m</code>上の加法\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>modulo</code>を法として剰余をとる構造体。\n<code>Montgomery</code>を生成するための構造体。\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>modulo</code>を法とする<code>MontgomeryBuilder</code>を生成する。\n正の無限大\n負の無限大\n正の無限大、負の無限大をもつ数\n有限の値\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>self</code>が<code>Inf</code>かを判定する。\n<code>self</code>が<code>NegInf</code>かを判定する。\n<code>self</code>が<code>Value(T)</code>かを判定する。\n<code>self</code>が<code>Value</code>ならばその中身を取り出す。\n乗算についての単位元をもつ。\n加算についての単位元をもつ。\n乗法の単位元を返す。\n加法の単位元を返す。\n乗法の逆元\n<code>pow</code>の結果の型\n<code>inv</code>の結果の型\n累乗\n<code>self</code>の乗法の逆元を求める。\n<code>self</code>の<code>p</code>乗を求める。\n有理数\n分母を返す\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>numerator / denominator</code>を表す有理数を生成する\n分子を返す\n全順序を実装した<code>f64</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n浮動小数点型\n整数型\n符号付きの数値型\n非負の数値型\nLL(1)構文解析\n括弧列の構文解析\n構文解析用の入力文字列\nLL(1)構文解析器\n規則: $\\mathtt{state} \\rightarrow \\alpha $ …\n規則: $\\mathtt{state} \\rightarrow \\varepsilon$ …\n一文字だけ消費する。\n現在の文字が<code>e</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>str</code>から<code>Input&lt;char&gt;</code>を構築する。\n<code>LL1Parser</code>を生成する。\n<code>state</code>を開始状態として、<code>input</code>…\n現在の文字を返す。\n…\n対応のある括弧列\n括弧列のパースの結果\n括弧以外\n複数の<code>Elem</code>からなる列\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n括弧列をパースする。\n閉じ括弧\n括弧の内部のパースの結果\n開き括弧\n<code>u64</code>型の範囲で乱数を返す。\n根付き木を構築する\n木\n非根付き木を構築する\n始点、終点、重み、番号をもつ木の辺\n<code>Tree</code>にもたせる辺の満たすトレイト。\n木のノード\n辺の重みの型\nAuxiliary Tree\n<code>Tree</code>を作る。\n根付きの<code>Tree</code>を作る。\n重心列挙\n重心分解\n子ノードへの辺\nTree depth query\nEuler tour\n辺の始点を返す。\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n始点\n重軽分解\n辺の番号\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n木の頂点数が<code>0</code>ならば<code>true</code>を返す。\n最小共通祖先\n木の頂点数を返す。\n隣接辺を列挙するイテレータを返す。\n隣接辺の個数を返す。\n頂点数<code>size</code>の<code>TreeBuilder</code>を生成する。\n頂点数<code>size</code>の<code>TreeBuilder</code>を生成する。\n<code>from</code>から<code>to</code>への重さ<code>weight</code>、辺番号<code>index</code>…\n<code>i</code>番目の頂点の<code>TreeNode</code>への参照を返す。\n各頂点の<code>TreeNode</code>…\n親ノードへの辺\n全方位木DP\n逆辺を返す。\n木に根があれば根を返す。\n…\n根付き木に変換\n辺の終点を返す。\n終点\n木DP\n木上の便利関数\n辺の重みを返す。\n重み\nAuxiliary Tree\n頂点集合<code>vs</code>からAuxiliaryTreeを構築する。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>AuxiliaryTree</code>を生成する。\n木の重心を列挙する\n重心分解\n<code>CentroidDecomposition</code>の頂点ノード\n子の頂点列\n深さ\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n木<code>tree</code>を重心分解する。\n重心分解後の頂点列への参照を返す。\n親の頂点\n部分木の大きさ\n…\n頂点<code>i</code>の<code>k</code>個遡った祖先の頂点を返す。\n頂点<code>i</code>から深さ<code>d</code>…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n頂点<code>i</code>に対応する区間を返す。\n根を<code>root</code>とする<code>tree</code>を基に、<code>TreeDepthQuery</code>…\nEuler tour\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>root</code>を根として<code>EulerTour</code>を構築する。\n頂点<code>i</code>に対応する番号を返す。\n頂点<code>i</code>の部分木に対応する範囲を返す。\n重軽分解\nReturns the argument unchanged.\n<strong>Time complexity</strong> $O(1)$\n<strong>Time complexity</strong> $O(1)$\nCalls <code>U::from(self)</code>.\n<strong>Time complexity</strong> $O(\\log n)$\n<strong>Time complexity</strong> $O(n)$\n<strong>Time complexity</strong> $O(1)$\n<strong>Time complexity</strong> $O(\\log n)$\n演算は可換性を仮定する。\n<strong>Time complexity</strong> $O(1)$\n<strong>Time complexity</strong> $O(1)$\nダブリングによる最小共通祖先\n<code>a</code>の<code>n</code>個上の祖先を求める。\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n…\n<code>a</code>と<code>b</code>の最小共通祖先を求める。\n<strong>Time complexity</strong> $O(n \\log n)$\n全方位木DP\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>RerootingDP</code>を構築する。\n<code>tree</code>上で、全方位DPを実行する。\n…\n根付き木に変換\n木DP\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n<code>TreeDP</code>を構築する。\n<code>root</code>を根にして、<code>tree</code>上でDPを実行する。\n木の任意の2頂点の距離の最大値を求める。\n…\n…\n…\n$\\sum \\sum f(a_i, a_j)$の形の問題\n2要素の差の絶対値の総和\n2要素の最大値の総和\n2要素の積の総和\n区間積の総和\n区間和の総和\n区間XORの総和\n2要素の和の総和\n2要素のXORの総和\n2要素の差の絶対値の総和\n2要素の最大値の総和\n2要素の積の総和\n区間積の総和\n区間和の総和\n区間XORの総和\n2要素の和の総和\n2要素のXORの総和")